// Generated by CoffeeScript 1.10.0
(function() {
  var Extractor, InfoJSONCreator, Informer, NodeCache, Parser, _, app, express, fs, iiif, image_cache, image_extraction, info_cache, path, resolve_image_path, tempfile;

  express = require('express');

  app = express();

  _ = require('lodash');

  path = require('path');

  fs = require('fs');

  tempfile = require('tempfile');

  iiif = require('iiif-image');

  Informer = iiif.Informer;

  Extractor = iiif.Extractor;

  Parser = iiif.ImageRequestParser;

  InfoJSONCreator = iiif.InfoJSONCreator;


  /*
  We'll create two different memory caches. One will keep image information
  for the life of the process and the other will be to cache images to the file
  system for a specified amount of time.
   */

  NodeCache = require('node-cache');

  info_cache = new NodeCache();

  image_cache = new NodeCache({
    stdTTL: 86400,
    checkperiod: 3600
  });

  image_cache.on('del', function(key, cached_image_path) {
    console.log("Image deleted: " + key + " " + cached_image_path);
    return fs.unlink(cached_image_path);
  });


  /*
  Simple file resolver!
  This could be changed to find images split across directories based on the id
  or look up the path to the image in a database. In this case we know all the
  images are going to be JP2s.
   */

  resolve_image_path = function(id) {
    return path.join(__dirname, "/../images/" + id + ".jp2");
  };


  /*
  This function needs the response object and the incoming URL to parse the URL,
  get information about the image, extract the requested image, and provide a
  response to the client.
   */

  image_extraction = function(res, url, params) {
    var cache_info, extractor_cb, image_path, info_cb, informer;
    image_path = resolve_image_path(params.identifier);
    extractor_cb = function(image) {
      var image_type;
      image_type = params.format === 'png' ? 'image/png' : 'image/jpeg';
      res.setHeader('Content-Type', image_type);
      res.send(image);
      if (!image_cache.get(url)) {
        image_path = tempfile("." + params.format);
        return fs.writeFile(image_path, image, function(err) {
          return image_cache.set(url, image_path);
        });
      }
    };
    info_cb = function(info) {
      var extractor, options;
      if (!info_cache.get(params.identifier)) {
        info_cache.set(params.identifier, info);
      }
      options = {
        path: image_path,
        params: params,
        info: info
      };
      extractor = new Extractor(options, extractor_cb);
      return extractor.extract();
    };
    cache_info = info_cache.get(params.identifier);
    if (cache_info) {
      return info_cb(_.cloneDeep(cache_info));
    } else {
      informer = new Informer(image_path, info_cb);
      return informer.inform();
    }
  };

  app.get('/index.html', function(req, res) {
    var index;
    index = path.join(__dirname, "/../app/index.html");
    return res.sendFile(index);
  });

  app.get('/openseadragon.js', function(req, res) {
    var osdjs;
    osdjs = path.join(__dirname, '/../node_modules/openseadragon/build/openseadragon/openseadragon.js');
    return res.sendFile(osdjs);
  });

  app.get('/openseadragon/images/:image', function(req, res) {
    var osdf;
    osdf = path.join(__dirname, "/../node_modules/openseadragon/build/openseadragon/images/" + req.params.image);
    return res.sendFile(osdf);
  });

  app.get('/openseadragon-start.js', function(req, res) {
    var osds;
    osds = path.join(__dirname, "/../app/openseadragon-start.js");
    return res.sendFile(osds);
  });

  app.get('*info.json', function(req, res) {
    var cache_info, id, image_path, info_cb, informer, scheme, server_info, url, url_parts;
    url = req.url;
    url_parts = url.split('/');
    id = url_parts[url_parts.length - 2];
    image_path = resolve_image_path(id);
    scheme = req.connection.encrypted != null ? 'https' : 'http';
    server_info = {
      id: scheme + "://" + req.headers.host + "/" + id,
      level: 1
    };
    info_cb = function(info) {
      var info_json_creator;
      if (!info_cache.get(id)) {
        info_cache.set(id, info);
      }
      info_json_creator = new InfoJSONCreator(info, server_info);
      return res.send(info_json_creator.info_json);
    };
    cache_info = info_cache.get(id);
    if (cache_info) {
      return info_cb(_.cloneDeep(cache_info));
    } else {
      informer = new Informer(image_path, info_cb);
      return informer.inform();
    }
  });

  app.get('*.(jpg|png)', function(req, res) {
    var cache_image_path, params, parser, url;
    url = req.url;
    parser = new Parser(url);
    params = parser.parse();
    cache_image_path = image_cache.get(url);
    if (cache_image_path) {
      return fs.stat(cache_image_path, function(err, stats) {
        if (err) {
          image_cache.del(url);
          return image_extraction(res, url, params);
        } else {
          return res.sendFile(cache_image_path);
        }
      });
    } else {

      /*
      TODO: Valid request format?
      Here we can do a quick check whether the format of the request is valid
      before trying the extraction. The check here would not be able to check
      whether the request is completely valid because we do not have the image
      information yet. In cases where we do have the image information from the
      cache we could do a fuller validation of the request (does it result in
      a 0 pixel image? Is the request out of bounds of the image?).
       */
      return image_extraction(res, url, params);
    }
  });

  app.get('*', function(req, res) {
    return res.send('This route catches anything else that does not match.');
  });

  app.listen(3000, function() {
    return console.log('Example IIIF image server listening on port 3000! Visit http://localhost:3000/index.html?id=trumpler14');
  });

}).call(this);
