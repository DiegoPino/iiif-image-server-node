// Generated by CoffeeScript 1.10.0
(function() {
  var NodeCache, app, bunyan, config, express, fs, image_cache, image_cache_checkperiod, image_cache_ttl, image_response, info_cache, info_json_response, log, log_file_path, path, port, resolve_image_path;

  express = require('express');

  app = express();

  path = require('path');

  fs = require('fs');

  config = require('config');


  /*
  Logging
  Currently we have one logger that logs to stdout and to a file in the log
  directory.
   */

  bunyan = require('bunyan');

  log_file_path = path.join(__dirname, '../log/iiif.log');

  log = bunyan.createLogger({
    name: 'iiif',
    streams: [
      {
        level: 'debug',
        stream: process.stdout
      }, {
        level: 'debug',
        path: log_file_path
      }
    ]
  });


  /*
  Caching
  We'll create two different memory caches. One will keep image information
  for the life of the process and the other will be to cache images to the file
  system for a specified amount of time.
   */

  NodeCache = require('node-cache');


  /*
  We cache the image information since getting the information from the cache will
  be faster than using a child process to return the information. This is
  completely in memory of the node instance so does not persist across instances
  or restarts.
   */

  info_cache = new NodeCache();


  /*
  The image_cache is really only used for expiration of an image from
  the file system. This works fine for single process applications, but if you
  begin to scale out to multiple processes then you will want to use a shared
  cache like Memcached.
   */

  image_cache_ttl = config.get('cache.image.ttl');

  image_cache_checkperiod = config.get('cache.image.checkperiod');

  log.info({
    ttl: image_cache_ttl,
    checkperiod: image_cache_checkperiod
  }, 'image_cache settings');

  image_cache = new NodeCache({
    stdTTL: image_cache_ttl,
    checkperiod: image_cache_checkperiod

    /*
    When an image gets deleted or expired from the cache unlink the cached file.
     */
  });

  image_cache.on('del', function(key, cached_image_path) {
    log.info({
      cache: 'image',
      op: 'del',
      key: key,
      img: cached_image_path
    }, "image deleted");
    return fs.unlink(cached_image_path, function(err) {});
  });


  /*
  Exports
   */

  exports.log = log;

  exports.image_cache = image_cache;

  exports.info_cache = info_cache;


  /*
  Image server specific functions.
  Note that the order of the code here is important!
  These local modules must be required _after_ the Exports section of this code
  so that they are available when we need them in these modules. Otherwise
  log etc. will be undefined within the modules.
   */

  info_json_response = require('./info-json-response');

  image_response = require('./image-response');

  resolve_image_path = require('./resolver').resolve_image_path;

  app.use(express["static"]('public'));

  if (config.get('viewer')) {
    app.get('/viewer/:id/', function(req, res) {
      var image_path;
      log.info({
        route: 'viewer',
        url: req.url,
        ip: req.ip
      });
      image_path = resolve_image_path(req.params.id);
      return fs.stat(image_path, function(err, stats) {
        var index;
        if (err) {
          return res.status(404).send('404');
        } else {
          index = path.join(__dirname, "/../app/index.html");
          res.setHeader('Content-Type', 'text/html');
          return res.sendFile(index);
        }
      });
    });
    app.get('/openseadragon.js', function(req, res) {
      var osdjs;
      osdjs = path.join(__dirname, '/../node_modules/openseadragon/build/openseadragon/openseadragon.js');
      return res.sendFile(osdjs);
    });
    app.get('/openseadragon/images/:image', function(req, res) {
      var osdf;
      osdf = path.join(__dirname, "/../node_modules/openseadragon/build/openseadragon/images/" + req.params.image);
      return res.sendFile(osdf);
    });
    app.get('/openseadragon-start.js', function(req, res) {
      var osds;
      osds = path.join(__dirname, "/../app/openseadragon-start.js");
      return res.sendFile(osds);
    });
  }

  app.get('*info.json', function(req, res) {
    log.info({
      route: 'info.json',
      url: req.url,
      ip: req.ip
    });
    if (config.get('cors')) {
      res.header("Access-Control-Allow-Origin", config.get('cors'));
    }
    return info_json_response(req, res, info_cache);
  });

  app.get('*default.:format(jpg|png)', function(req, res) {
    log.info({
      route: 'image',
      url: req.url,
      ip: req.ip
    });
    return image_response(req, res, info_cache, image_cache);
  });

  app.get('*', function(req, res) {
    var possible_image_identifier, possible_image_path, url, url_parts;
    log.info({
      route: '*',
      url: req.url,
      ip: req.ip
    });
    url = req.url;
    url_parts = url.split('/');
    possible_image_identifier = url_parts[0];
    possible_image_path = resolve_image_path(possible_image_identifier);
    return fs.stat(possible_image_path, function(err, stats) {
      if (err) {
        return res.status(400).send('400 not found');
      } else {
        return res.redirect('303', "/" + possible_image_identifier + "/info.json");
      }
    });
  });

  if (require.main === module) {
    port = process.env.PORT || 3001;
    app.listen(port, function() {
      return console.log('Example IIIF image server listening on port 3001! Visit http://localhost:3001/viewer/trumpler14');
    });
  }

  exports.app = app;

}).call(this);
