// Generated by CoffeeScript 1.10.0
(function() {
  var InfoJSONCreator, Informer, NodeCache, Parser, Validator, _, app, checkperiod, config, express, fs, iiif, image_cache, image_extraction, info_cache, jp2_binary, path, path_for_image_cache_file, resolve_image_path, ttl;

  express = require('express');

  app = express();

  _ = require('lodash');

  path = require('path');

  fs = require('fs');

  config = require('config');

  jp2_binary = config.get('jp2_binary');

  iiif = require('iiif-image');

  Informer = iiif.Informer(jp2_binary);

  Parser = iiif.ImageRequestParser;

  InfoJSONCreator = iiif.InfoJSONCreator;

  Validator = iiif.Validator;

  image_extraction = require('./image-extraction').image_extraction;

  resolve_image_path = require('./resolver').resolve_image_path;

  path_for_image_cache_file = require('./path-for-image-cache-file');


  /*
  Caching
  We'll create two different memory caches. One will keep image information
  for the life of the process and the other will be to cache images to the file
  system for a specified amount of time.
   */

  NodeCache = require('node-cache');


  /*
  We cache the image information since getting the information from the cache will
  be faster than using a child process to return the information. This is
  completely in memory of the node instance so does not persist across instances
  or restarts.
   */

  info_cache = new NodeCache();


  /*
  The image_cache is really only used for expiration of an image from
  the file system. This works fine for single process applications, but if you
  begin to scale out to multiple processes then you will want to use a shared
  cache like Memcached.
   */

  ttl = config.get('cache.image.ttl');

  checkperiod = config.get('cache.image.checkperiod');

  console.log("Image cache: ttl:" + ttl + " checkperiod:" + checkperiod);

  image_cache = new NodeCache({
    stdTTL: ttl,
    checkperiod: checkperiod
  });

  image_cache.on('del', function(key, cached_image_path) {
    console.log("Image deleted: " + key + " " + cached_image_path);
    return fs.unlink(cached_image_path, function(err) {});
  });

  app.use(express["static"]('public'));

  app.get('/index.html', function(req, res) {
    var index;
    index = path.join(__dirname, "/../app/index.html");
    return res.sendFile(index);
  });

  app.get('/openseadragon.js', function(req, res) {
    var osdjs;
    osdjs = path.join(__dirname, '/../node_modules/openseadragon/build/openseadragon/openseadragon.js');
    return res.sendFile(osdjs);
  });

  app.get('/openseadragon/images/:image', function(req, res) {
    var osdf;
    osdf = path.join(__dirname, "/../node_modules/openseadragon/build/openseadragon/images/" + req.params.image);
    return res.sendFile(osdf);
  });

  app.get('/openseadragon-start.js', function(req, res) {
    var osds;
    osds = path.join(__dirname, "/../app/openseadragon-start.js");
    return res.sendFile(osds);
  });

  app.get('*info.json', function(req, res) {

    /*
    Information requests are easy to parse, so we just take the next to the
    last element to make our id. Note that this image server does not
    decodeURIComponent as our implementation of a file resolver in
    resolve_image_path is not robust enough to defend against a directory
    traversal attack.
     */
    var id, image_path, url, url_parts;
    url = req.url;
    url_parts = url.split('/');
    id = url_parts[url_parts.length - 2];
    image_path = resolve_image_path(id);

    /*
    Check to see if the image exists. If not return a 404. If the image exists
    return the information about the image.
     */
    return fs.stat(image_path, function(err, stats) {
      var cache_info, info_cb, informer, scheme, server_info;
      if (err) {
        return res.state(404).send('404');
      } else {
        scheme = req.connection.encrypted != null ? 'https' : 'http';
        server_info = {
          id: scheme + "://" + req.headers.host + "/" + id,
          level: 1
        };
        info_cb = function(info) {
          var info_json_creator;
          if (!info_cache.get(id)) {
            info_cache.set(id, info);
          }
          info_json_creator = new InfoJSONCreator(info, server_info);
          return res.send(info_json_creator.info_json);
        };
        cache_info = info_cache.get(id);
        if (cache_info) {
          return info_cb(_.cloneDeep(cache_info));
        } else {
          informer = new Informer(image_path, info_cb);
          return informer.inform();
        }
      }
    });
  });

  app.get('*.:format(jpg|png)', function(req, res) {
    var image_temp_file, url;
    url = req.url;

    /*
    If the image exists just serve that up. This allows cached images
    to be used across instances of the application, but will still not handle
    cache expiration in a unified way. This is why we check for the status of the
    file rather than relying on the memory cache to know whether this is an
    image_cache hit or not.
     */
    image_temp_file = path_for_image_cache_file(url);
    return fs.stat(image_temp_file, function(err, stats) {
      var image_path, params, parser;
      if (!err) {
        console.log("cache image hit: " + url + " " + image_temp_file);
        image_cache.ttl(url, ttl);
        return res.sendFile(image_temp_file);
      } else {
        console.log("cache image miss: " + url + " " + image_temp_file);

        /*
        First we parse the URL to extract all the information we'll need from the
        request to choose the correct image.
         */
        parser = new Parser(url);
        params = parser.parse();
        image_path = resolve_image_path(params.identifier);

        /*
        Check to see if the source image exists. If not return a 404.
         */
        return fs.stat(image_path, function(err, stats) {
          var image_info, valid_request, validator, validity;
          if (err) {
            return res.status(404).send('404');
          } else {

            /*
            We do a quick check whether the parameters of the request are valid
            before trying the extraction. If we do not have the image information
            yet, the check here is not able to check whether the request is
            completely valid.
            
            In cases where we do have the image information from the
            info_cache (say when we've already responded to an info.json request)
            we do a fuller validation of the request (is it in bounds?).
             */
            image_info = info_cache.get(params.identifier);
            valid_request = image_info ? (validator = new Validator(params, image_info), validity = validator.valid(), validity ? console.log("valid with info: " + url) : console.log("invalid with info: " + url), validity) : (validator = new Validator(params), validity = validator.valid_params(), validity ? console.log("valid with params: " + url) : console.log("invalid with params: " + url), validity);
            if (valid_request) {
              return image_extraction(res, url, params, info_cache, image_cache);
            } else {
              console.log("invalid request: " + url);
              return res.status(400).send('400 error');
            }
          }
        });
      }
    });
  });

  app.get('*', function(req, res) {
    return res.status(404).send('404 not found');
  });

  app.listen(3001, function() {
    return console.log('Example IIIF image server listening on port 3001! Visit http://localhost:3000/index.html?id=trumpler14');
  });

}).call(this);
