// Generated by CoffeeScript 1.10.0
(function() {
  var Parser, Validator, config, fs, iiif, image_extraction, image_response, path_for_image_cache_file, resolve_image_path, ttl;

  fs = require('fs');

  config = require('config');

  iiif = require('iiif-image');

  Parser = iiif.ImageRequestParser;

  Validator = iiif.Validator;

  resolve_image_path = require('./resolver').resolve_image_path;

  path_for_image_cache_file = require('./path-for-image-cache-file');

  image_extraction = require('./image-extraction');

  ttl = config.get('cache.image.ttl');

  image_response = function(req, res, info_cache, image_cache) {
    var image_temp_file, url;
    url = req.url;

    /*
    If the image exists just serve that up. This allows cached images
    to be used across instances of the application, but will still not handle
    cache expiration in a unified way. This is why we check for the status of the
    file rather than relying on the memory cache to know whether this is an
    image_cache hit or not.
     */
    image_temp_file = path_for_image_cache_file(url);
    return fs.stat(image_temp_file, function(err, stats) {
      var image_path, params, parser;
      if (!err) {
        console.log("cache image hit: " + url + " " + image_temp_file);
        image_cache.ttl(url, ttl);
        return res.sendFile(image_temp_file);
      } else {
        console.log("cache image miss: " + url + " " + image_temp_file);

        /*
        First we parse the URL to extract all the information we'll need from the
        request to choose the correct image.
         */
        parser = new Parser(url);
        params = parser.parse();
        image_path = resolve_image_path(params.identifier);

        /*
        Check to see if the source image exists. If not return a 404.
         */
        return fs.stat(image_path, function(err, stats) {
          var image_info, valid_request, validator, validity;
          if (err) {
            return res.status(404).send('404');
          } else {

            /*
            We do a quick check whether the parameters of the request are valid
            before trying the extraction. If we do not have the image information
            yet, the check here is not able to check whether the request is
            completely valid.
            
            In cases where we do have the image information from the
            info_cache (say when we've already responded to an info.json request)
            we do a fuller validation of the request (is it in bounds?).
             */
            image_info = info_cache.get(params.identifier);
            valid_request = image_info ? (validator = new Validator(params, image_info), validity = validator.valid(), validity ? console.log("valid with info: " + url) : console.log("invalid with info: " + url), validity) : (validator = new Validator(params), validity = validator.valid_params(), validity ? console.log("valid with params: " + url) : console.log("invalid with params: " + url), validity);
            if (valid_request) {
              return image_extraction(res, url, params, info_cache, image_cache);
            } else {
              console.log("invalid request: " + url);
              return res.status(400).send('400 error');
            }
          }
        });
      }
    });
  };

  module.exports = image_response;

}).call(this);
