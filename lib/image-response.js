// Generated by CoffeeScript 1.10.0
(function() {
  var Parser, Validator, config, enrich_params, fs, iiif, image_extraction, image_response, info_cache, log, path_for_cache_file, resolve_image_path, too_big, ttl;

  fs = require('fs');

  log = require('./index').log;

  info_cache = require('./index').info_cache;

  config = require('config');

  iiif = require('iiif-image');

  Parser = iiif.ImageRequestParser;

  Validator = iiif.Validator;

  enrich_params = iiif.enrich_params;

  too_big = require('./helpers').too_big;

  resolve_image_path = require('./resolver').resolve_image_path;

  path_for_cache_file = require('./path-for-cache-file');

  image_extraction = require('./image-extraction');

  ttl = config.get('cache.image.ttl');

  image_response = function(req, res) {
    var image_temp_file, url;
    url = req.url;

    /*
    If the image exists just serve that up. This allows cached images
    to be used across instances of the application.
     */
    image_temp_file = path_for_cache_file(url);
    return fs.stat(image_temp_file, function(err, stats) {
      var image_path, params, parser;
      if (!err) {
        log.info({
          cache: 'image',
          found: 'hit',
          url: url,
          img: image_temp_file
        });
        log.info({
          res: 'image',
          url: url,
          ip: req.ip
        }, 'response image');
        return res.sendFile(image_temp_file);
      } else {
        log.info({
          cache: 'image',
          found: 'miss',
          url: url,
          img: image_temp_file
        });

        /*
        First we parse the URL to extract all the information we'll need from the
        request to choose the correct image.
         */
        parser = new Parser(url);
        params = parser.parse();
        image_path = resolve_image_path(params.identifier);

        /*
        Check to see if the source image exists. If not return a 404.
         */
        return fs.stat(image_path, function(err, stats) {
          var image_info, valid_request, validator, validity;
          if (err) {
            log.info({
              res: '404',
              url: url,
              ip: req.ip
            }, '404');
            return res.status(404).send('404');
          } else {

            /*
            We do a quick check whether the parameters of the request are valid
            before trying the extraction. If we do not have the image information
            yet, the check here is not able to check whether the request is
            completely valid.
            
            In cases where we do have the image information from the
            info_cache (say when we've already responded to an info.json request)
            we do a fuller validation of the request (is it in bounds?).
             */
            image_info = info_cache.get(params.identifier);
            valid_request = image_info ? (params = enrich_params(params, image_info), validator = new Validator(params, image_info), validity = validator.valid() && !too_big(params, image_info), validity ? log.info({
              valid: true,
              test: 'info',
              url: url,
              ip: req.ip
            }, 'valid w/ info') : log.info({
              valid: false,
              test: 'info',
              url: url,
              ip: req.ip
            }, 'invalid w/ info'), validity) : (validator = new Validator(params), validity = validator.valid_params(), validity ? log.info({
              valid: true,
              test: 'params',
              url: url,
              ip: req.ip
            }, 'valid with params') : log.info({
              valid: false,
              test: 'params',
              url: url,
              ip: req.ip
            }, 'invalid with params'), validity);
            if (valid_request) {
              return image_extraction(req, res, params);
            } else {
              log.info({
                res: '400',
                url: url,
                ip: req.ip
              }, '400');
              return res.status(400).send('400 invalid');
            }
          }
        });
      }
    });
  };

  module.exports = image_response;

}).call(this);
